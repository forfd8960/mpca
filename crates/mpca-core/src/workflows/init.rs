//! Init workflow for MPCA.
//!
//! This module implements the `mpca init` workflow, which sets up a repository
//! for MPCA use by creating necessary directories and configuration files.

use crate::config::MpcaConfig;
use crate::error::{MPCAError, Result};
use crate::tools::fs::FsAdapter;
use crate::tools::git::GitAdapter;

/// Initializes a repository for MPCA use.
///
/// This function performs the following steps:
/// 1. Verifies the directory is a git repository
/// 2. Checks if already initialized (to prevent double-initialization)
/// 3. Creates `.mpca/` directory structure
/// 4. Creates `.trees/` directory for worktrees
/// 5. Creates default `.mpca/config.toml`
/// 6. Updates `.gitignore` to exclude `.trees/`
/// 7. Creates or updates `CLAUDE.md` with links to MPCA directories
///
/// # Arguments
///
/// * `config` - MPCA configuration containing repository paths
/// * `fs` - File system adapter for read/write operations
/// * `git` - Git adapter for repository checks
///
/// # Returns
///
/// `Ok(())` on success, or an error if initialization fails.
///
/// # Errors
///
/// Returns:
/// - `MPCAError::NotGitRepository` if the directory is not a git repository
/// - `MPCAError::AlreadyInitialized` if MPCA is already initialized
/// - `MPCAError::FileWriteError` if file creation fails
/// - `MPCAError::PermissionDenied` if lacking write permissions
pub fn init_project(config: &MpcaConfig, fs: &dyn FsAdapter, git: &dyn GitAdapter) -> Result<()> {
    // Step 1: Verify it's a git repository
    if !git.is_git_repo(&config.repo_root) {
        return Err(MPCAError::NotGitRepository(config.repo_root.clone()));
    }

    // Step 2: Check if already initialized
    if fs.exists(&config.config_file) {
        return Err(MPCAError::AlreadyInitialized);
    }

    // Step 3: Create .mpca/ directory structure
    let mpca_dir = config.repo_root.join(".mpca");
    fs.create_dir_all(&mpca_dir)?;
    fs.create_dir_all(&config.specs_dir)?;

    // Step 4: Create .trees/ directory
    fs.create_dir_all(&config.trees_dir)?;

    // Step 5: Create default config.toml
    let default_config = generate_default_config();
    fs.write(&config.config_file, &default_config)?;

    // Step 6: Update .gitignore to exclude .trees/
    update_gitignore(config, fs)?;

    // Step 7: Create or update CLAUDE.md
    create_or_update_claude_md(config, fs)?;

    Ok(())
}

/// Generates the default MPCA configuration file content.
///
/// # Returns
///
/// A string containing the default `config.toml` content.
fn generate_default_config() -> String {
    r#"# MPCA Configuration
# This file is automatically generated by `mpca init`.
# You can customize these settings for your workflow.

[git]
# Automatically commit changes during workflows
auto_commit = true
# Branch naming pattern (supports {feature_slug} placeholder)
branch_naming = "feature/{feature_slug}"

[review]
# Enable code review workflow
enabled = false
# List of reviewers (GitHub usernames)
reviewers = []

[agent_modes]
# Agent modes for different workflow phases
# Options: "standard" or "code" (Claude Code preset)
init = "standard"
plan = "code"
run = "code"
verify = "standard"
review = "code"

[tool_sets]
# Tool sets for different workflow phases
# Options: "minimal", "standard", "full"
init = "minimal"
plan = "standard"
run = "full"
verify = "standard"
review = "standard"
"#
    .to_string()
}

/// Updates the `.gitignore` file to exclude `.trees/` directory.
///
/// If `.gitignore` doesn't exist, creates it. If it exists, appends the
/// entry only if not already present.
///
/// # Arguments
///
/// * `config` - MPCA configuration
/// * `fs` - File system adapter
///
/// # Returns
///
/// `Ok(())` on success, or an error if the operation fails.
fn update_gitignore(config: &MpcaConfig, fs: &dyn FsAdapter) -> Result<()> {
    let gitignore_path = config.repo_root.join(".gitignore");

    let content = if fs.exists(&gitignore_path) {
        let existing = fs.read_to_string(&gitignore_path)?;

        // Check if .trees/ is already in .gitignore
        if existing.lines().any(|line| line.trim() == ".trees/") {
            return Ok(());
        }

        // Append to existing content
        format!(
            "{}\n\n# MPCA worktrees (managed by mpca)\n.trees/\n",
            existing.trim()
        )
    } else {
        // Create new .gitignore
        "# MPCA worktrees (managed by mpca)\n.trees/\n".to_string()
    };

    fs.write(&gitignore_path, &content)?;

    Ok(())
}

/// Creates or updates the `CLAUDE.md` file with MPCA links.
///
/// If `CLAUDE.md` doesn't exist, creates it with a basic template.
/// If it exists, ensures it has links to MPCA directories.
///
/// # Arguments
///
/// * `config` - MPCA configuration
/// * `fs` - File system adapter
///
/// # Returns
///
/// `Ok(())` on success, or an error if the operation fails.
fn create_or_update_claude_md(config: &MpcaConfig, fs: &dyn FsAdapter) -> Result<()> {
    let claude_md_path = &config.claude_md;

    let content = if fs.exists(claude_md_path) {
        let existing = fs.read_to_string(claude_md_path)?;

        // Check if MPCA section already exists
        if existing.contains("## MPCA") {
            return Ok(());
        }

        // Append MPCA section
        format!("{}\n\n{}", existing.trim(), generate_mpca_section())
    } else {
        // Create new CLAUDE.md with MPCA section
        format!("# Claude Agent Instructions\n\n{}", generate_mpca_section())
    };

    fs.write(claude_md_path, &content)?;

    Ok(())
}

/// Generates the MPCA section for CLAUDE.md.
///
/// # Returns
///
/// A string containing the MPCA documentation section.
fn generate_mpca_section() -> String {
    r#"## MPCA (Mine Personal Coding Agent)

This repository is configured to use MPCA for automated feature development.

### Directory Structure

- `.mpca/`: MPCA configuration and feature specifications
  - `config.toml`: MPCA settings
  - `specs/`: Feature specifications and state
- `.trees/`: Git worktrees for feature development (excluded from version control)

### Workflows

- `mpca init`: Initialize repository for MPCA use (already done)
- `mpca plan <feature-slug>`: Plan a new feature with interactive TUI
- `mpca run <feature-slug>`: Execute a feature plan with automated implementation

### Configuration

See `.mpca/config.toml` for customization options.
"#
    .to_string()
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::tools::fs_impl::StdFsAdapter;
    use crate::tools::git_impl::StdGitAdapter;
    use std::process::Command;
    use tempfile::TempDir;

    fn init_test_repo(dir: &std::path::Path) {
        Command::new("git")
            .args(["init"])
            .current_dir(dir)
            .output()
            .unwrap();

        Command::new("git")
            .args(["config", "user.name", "Test User"])
            .current_dir(dir)
            .output()
            .unwrap();

        Command::new("git")
            .args(["config", "user.email", "test@example.com"])
            .current_dir(dir)
            .output()
            .unwrap();
    }

    #[test]
    fn test_init_project_success() {
        let temp_dir = TempDir::new().unwrap();
        init_test_repo(temp_dir.path());

        let config = MpcaConfig::new(temp_dir.path().to_path_buf());
        let fs = StdFsAdapter::new();
        let git = StdGitAdapter::new();

        let result = init_project(&config, &fs, &git);
        assert!(result.is_ok());

        // Verify directories were created
        assert!(fs.exists(&config.specs_dir));
        assert!(fs.exists(&config.trees_dir));
        assert!(fs.exists(&config.config_file));

        // Verify .gitignore was updated
        let gitignore_path = temp_dir.path().join(".gitignore");
        assert!(fs.exists(&gitignore_path));
        let gitignore_content = fs.read_to_string(&gitignore_path).unwrap();
        assert!(gitignore_content.contains(".trees/"));

        // Verify CLAUDE.md was created
        assert!(fs.exists(&config.claude_md));
        let claude_md_content = fs.read_to_string(&config.claude_md).unwrap();
        assert!(claude_md_content.contains("## MPCA"));
    }

    #[test]
    fn test_init_project_not_git_repo() {
        let temp_dir = TempDir::new().unwrap();

        let config = MpcaConfig::new(temp_dir.path().to_path_buf());
        let fs = StdFsAdapter::new();
        let git = StdGitAdapter::new();

        let result = init_project(&config, &fs, &git);
        assert!(result.is_err());
        assert!(matches!(
            result.unwrap_err(),
            MPCAError::NotGitRepository(_)
        ));
    }

    #[test]
    fn test_init_project_already_initialized() {
        let temp_dir = TempDir::new().unwrap();
        init_test_repo(temp_dir.path());

        let config = MpcaConfig::new(temp_dir.path().to_path_buf());
        let fs = StdFsAdapter::new();
        let git = StdGitAdapter::new();

        // Initialize once
        init_project(&config, &fs, &git).unwrap();

        // Try to initialize again
        let result = init_project(&config, &fs, &git);
        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), MPCAError::AlreadyInitialized));
    }

    #[test]
    fn test_generate_default_config() {
        let config = generate_default_config();
        assert!(config.contains("[git]"));
        assert!(config.contains("auto_commit"));
        assert!(config.contains("[review]"));
        assert!(config.contains("[agent_modes]"));
        assert!(config.contains("[tool_sets]"));
    }

    #[test]
    fn test_update_gitignore_new() {
        let temp_dir = TempDir::new().unwrap();
        let config = MpcaConfig::new(temp_dir.path().to_path_buf());
        let fs = StdFsAdapter::new();

        update_gitignore(&config, &fs).unwrap();

        let gitignore_path = temp_dir.path().join(".gitignore");
        assert!(fs.exists(&gitignore_path));

        let content = fs.read_to_string(&gitignore_path).unwrap();
        assert!(content.contains(".trees/"));
    }

    #[test]
    fn test_update_gitignore_existing() {
        let temp_dir = TempDir::new().unwrap();
        let config = MpcaConfig::new(temp_dir.path().to_path_buf());
        let fs = StdFsAdapter::new();

        // Create existing .gitignore
        let gitignore_path = temp_dir.path().join(".gitignore");
        fs.write(&gitignore_path, "*.log\ntarget/\n").unwrap();

        update_gitignore(&config, &fs).unwrap();

        let content = fs.read_to_string(&gitignore_path).unwrap();
        assert!(content.contains("*.log"));
        assert!(content.contains("target/"));
        assert!(content.contains(".trees/"));
    }

    #[test]
    fn test_update_gitignore_already_has_entry() {
        let temp_dir = TempDir::new().unwrap();
        let config = MpcaConfig::new(temp_dir.path().to_path_buf());
        let fs = StdFsAdapter::new();

        // Create .gitignore with .trees/ already present
        let gitignore_path = temp_dir.path().join(".gitignore");
        fs.write(&gitignore_path, ".trees/\n").unwrap();

        update_gitignore(&config, &fs).unwrap();

        let content = fs.read_to_string(&gitignore_path).unwrap();
        // Should only have one .trees/ entry
        assert_eq!(content.matches(".trees/").count(), 1);
    }

    #[test]
    fn test_create_claude_md_new() {
        let temp_dir = TempDir::new().unwrap();
        let config = MpcaConfig::new(temp_dir.path().to_path_buf());
        let fs = StdFsAdapter::new();

        create_or_update_claude_md(&config, &fs).unwrap();

        assert!(fs.exists(&config.claude_md));
        let content = fs.read_to_string(&config.claude_md).unwrap();
        assert!(content.contains("## MPCA"));
        assert!(content.contains("mpca init"));
        assert!(content.contains("mpca plan"));
        assert!(content.contains("mpca run"));
    }

    #[test]
    fn test_create_claude_md_existing() {
        let temp_dir = TempDir::new().unwrap();
        let config = MpcaConfig::new(temp_dir.path().to_path_buf());
        let fs = StdFsAdapter::new();

        // Create existing CLAUDE.md
        fs.write(
            &config.claude_md,
            "# Existing content\n\nSome instructions.\n",
        )
        .unwrap();

        create_or_update_claude_md(&config, &fs).unwrap();

        let content = fs.read_to_string(&config.claude_md).unwrap();
        assert!(content.contains("# Existing content"));
        assert!(content.contains("Some instructions"));
        assert!(content.contains("## MPCA"));
    }

    #[test]
    fn test_create_claude_md_already_has_section() {
        let temp_dir = TempDir::new().unwrap();
        let config = MpcaConfig::new(temp_dir.path().to_path_buf());
        let fs = StdFsAdapter::new();

        // Create CLAUDE.md with MPCA section already present
        let initial_content = "# Instructions\n\n## MPCA\n\nAlready configured.\n";
        fs.write(&config.claude_md, initial_content).unwrap();

        create_or_update_claude_md(&config, &fs).unwrap();

        let content = fs.read_to_string(&config.claude_md).unwrap();
        // Should not have duplicate MPCA sections
        assert_eq!(content, initial_content);
    }
}
